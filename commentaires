Prop: en première phase, le but est d'obtenir:
- les produits scalaires
- les numéros de cas
- une liste avec les nombre de cas pour chaque "thread"

En deuxième phase, on transforme les comptes en offsets.

En troisième phase, on fait un parcourt des produits scalaires et on colle les index triés à partir des offsets.

========================================================================================================================================
Optimisations ? L'idéal serait de travailler sur un cas réel, avec les diagramme de puissance

========================================================================================================================================
Interface de powerdiagram

-> c'est l'endroit où il faut faire du out of core
-> il faut trier les diracs dans des boites de ~ 30
-> on pourrait chronométrer le temps de récupération 

Prop: on fait des histogrammes pour déterminer la répartition en out-of core.

A priori, on doit faire un premier passage pour avoir
- nb elements
- min max

========================================================================================================================================
Prop: les valeurs sont communiquées sous forme sérialisées.

C'est lors de la génération de code qu'on désérialise dans le bon type.

Prop simple: on utilise un type (spécifié par chaine de caractère) et un "pointeur".
   Le pointeur doit idéalement dire sur quelle machine on est

Sortie des tasks: 
  Prop 1: les noyaux sortent un pointeur.

On a besoin de Value pour construire les tasks 

Prop: Task se base sur TaskRef


========================================================================================================================================
cta 15ème lecourbe,


========================================================================================================================================
Rq: on pourrait faire le plane_cut en 1 seul coup.

========================================================================================================================================
Rq: on aimerait bien partager des outputs pour faire des vues

========================================================================================================================================
GPU =>

========================================================================================================================================
powerdiagram => 
  en entrée, un tenseur pour les x, les y, et les poids.

1ère étape: min max du domaine
2ème étape: zcoords + histogram pour le partage
  => si tout est sur la même machine (pas de GPU), on peut directement passer à l'étape où on fait des boites 
3ème étape: on fait des boites avec des bornes polynomiales pour les potentiels.
  => on peut faire un tri par zcoords
  => les boites doivent prendre ~

Tri radix:
 * on envoie les valeurs d'origine à toutes les machines qui en ont besoin 
    => on va envoyer trop de valeurs 
 * on envoie uniquement les valeurs de sortie. 

Dans la deuxième solution, on pourrait pour chaque entrée faire un premier tri. 

========================================================================================================================================
Ça serait bien si les paramètres des noyaux pouvaient être des Résultats de task.

Ça serait bien aussi de pouvoir partager des sorties de tasks (pas uniquement du move).

=> Output { void *data; std::size_t ref_count; std::string type; }

Prop: TypedOutput<T>{ T *data; std::size_t ref_count; }

mais pour conversion vers output, il faudrait Output { void *data; std::size_t *ref_count; std::string type; }


