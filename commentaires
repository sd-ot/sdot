Prop: en première phase, le but est d'obtenir:
- les produits scalaires
- les numéros de cas
- une liste avec les nombre de cas pour chaque "thread"

En deuxième phase, on transforme les comptes en offsets.

En troisième phase, on fait un parcourt des produits scalaires et on colle les index triés à partir des offsets.

========================================================================================================================================
Optimisations ? L'idéal serait de travailler sur un cas réel, avec les diagramme de puissance

========================================================================================================================================
Interface de powerdiagram

-> c'est l'endroit où il faut faire du out of core
-> il faut trier les diracs dans des boites de ~ 30
-> on pourrait chronométrer le temps de récupération 

Prop: on fait des histogrammes pour déterminer la répartition en out-of core.

A priori, on doit faire un premier passage pour avoir
- nb elements
- min max

========================================================================================================================================
Prop: les valeurs sont communiquées sous forme sérialisées.

C'est lors de la génération de code qu'on désérialise dans le bon type.

Prop simple: on utilise un type (spécifié par chaine de caractère) et un "pointeur".
   Le pointeur doit idéalement dire sur quelle machine on est

Sortie des tasks: 
  Prop 1: les noyaux sortent un pointeur.

On a besoin de Value pour construire les tasks 

Prop: Task se base sur TaskRef


========================================================================================================================================
cta 15ème lecourbe,


========================================================================================================================================
GPU =>

========================================================================================================================================
Pour créer les éléments, il faudrait appeler du code généré.

=> il faudrait pouvoir créer des sous taches

Prop: un attribut sub_task + un attribut parent_of_sub_task

On pourrait aussi modifier le graph en direct, par exemple en insérant des taches dans les parents.

Pb: plane_cut reste référencé dans SetOfElem. Pb de ref_count + pb dans SetOfElem qui n'aura pas la bonne référence.
  Prop 1: on ajoute une task intermédiaire
  Prop 2: on 